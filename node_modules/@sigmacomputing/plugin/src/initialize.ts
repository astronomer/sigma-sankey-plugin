import { PluginInstance, PluginConfig, PluginMessageResponse } from './types';

export function initialize<T = {}>(): PluginInstance<T> {
  const pluginConfig: Partial<PluginConfig<T>> = {
    config: {} as T,
  };
  const listeners: {
    [event: string]: Function[];
  } = {};

  for (const [key, value] of new URL(
    document.location.toString(),
  ).searchParams.entries())
    pluginConfig[key] = JSON.parse(value);

  const listener = (e: PluginMessageResponse) => {
    emit(e.data.type, e.data.result, e.data.error);
  };

  window.addEventListener('message', listener, false);

  on('wb:plugin:config:update', (config: PluginConfig<T>) => {
    Object.assign(pluginConfig, config);
    emit('config', pluginConfig.config ?? {});
  });

  // send initialize event
  void execPromise('wb:plugin:init').then(config => {
    Object.assign(pluginConfig, config);
    emit('init', pluginConfig);
    emit('config', pluginConfig.config);
  });

  function on(event: string, listener: Function) {
    listeners[event] = listeners[event] || [];
    listeners[event].push(listener);
  }

  function off(event: string, listener: Function) {
    if (listeners[event] == null) return;
    listeners[event] = listeners[event].filter(a => a !== listener);
  }

  function emit(event: string, ...args: any) {
    Object.values(listeners[event] || []).forEach(fn => fn(...args));
  }

  function execPromise<R>(event: string, ...args: any): Promise<R> {
    return new Promise((resolve, reject) => {
      const callback = (data: R, error: any) => {
        if (error) reject(error);
        else resolve(data);
        off(event, callback);
      };
      on(event, callback);
      window.parent.postMessage(
        { type: event, args, elementId: pluginConfig.id },
        pluginConfig?.wbOrigin ?? '*',
      );
    });
  }

  return {
    get sigmaEnv() {
      return pluginConfig.sigmaEnv;
    },
    config: {
      getKey(key) {
        return pluginConfig?.config?.[key]!;
      },
      get() {
        return pluginConfig.config;
      },
      set(partialConfig) {
        void execPromise('wb:plugin:config:update', partialConfig);
      },
      setKey(key, value) {
        void execPromise('wb:plugin:config:update', {
          [key]: value,
        });
      },
      subscribe(listener) {
        on('config', listener);
        return () => off('config', listener);
      },
      configureEditorPanel(options) {
        void execPromise('wb:plugin:config:inspector', options);
      },
    },
    elements: {
      getElementColumns(id) {
        return execPromise('wb:plugin:element:columns:get', id);
      },
      subscribeToElementColumns(id, callback) {
        const eventName = `wb:plugin:element:${id}:columns`;
        on(eventName, callback);
        void execPromise('wb:plugin:element:subscribe:columns', id);

        return () => {
          off(eventName, callback);
          void execPromise('wb:plugin:element:unsubscribe:columns', id);
        };
      },
      subscribeToElementData(id, callback) {
        const eventName = `wb:plugin:element:${id}:data`;
        on(eventName, callback);
        void execPromise('wb:plugin:element:subscribe:data', id);

        return () => {
          off(eventName, callback);
          void execPromise('wb:plugin:element:unsubscribe:data', id);
        };
      },
    },
    destroy: function() {
      Object.keys(listeners).forEach(event => delete listeners[event]);
      window.removeEventListener('message', listener, false);
    },
  };
}
